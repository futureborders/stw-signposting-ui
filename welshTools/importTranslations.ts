/**
 * Copyright 2023 Crown Copyright (Single Trade Window)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as fs from 'fs';
import * as csv from 'csv/sync';
import * as en from '../src/translation/en';
import * as cy from '../src/translation/cy';

const outputDir = `${__dirname}/../translationOutput`;

if (!fs.existsSync(outputDir)){
    fs.mkdirSync(outputDir);
}

let inputFilename = `${outputDir}/translations.csv`;

if(process.argv[2]) {
    inputFilename = process.argv[2];
}

const outputFilename = `${__dirname}/../src/translation/cy.ts`;

interface TranslationRecord {
    key: string,
    en: string,
    cy: string
}

const indentString = '  ';

let output = `/**
 * Copyright 2023 Crown Copyright (Single Trade Window)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/* eslint-disable */
/* istanbul ignore file */
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// WARNING: This file is automatically generated - do not edit it directly unless you know what you're doing.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

import { MeasureType } from '../interfaces/enums.interface';

const Translation = {
`;

const recordMap: { [key: string]: TranslationRecord } = {};
const csvKeyUsageTracker = new Set<string>();

if(fs.existsSync(inputFilename)) {
    console.info(`Importing translations from CSV file ${inputFilename}`);

    const csvContent = fs.readFileSync(inputFilename);

    csv.parse(csvContent).forEach(([key, en, cy]: [string, string, string]) => {
        recordMap[key] = {
            key,
            en,
            cy
        };

        csvKeyUsageTracker.add(key);
    });
} else {
    console.info('No CSV file found - will just rebuild the cy.ts file.');
}

function sanitise(input: string): string {
    return input
        .replace(/\r\n/g, '\n');
}

function writeValue(indent: number, key: string, value: string, isArray: boolean) {
    if(isArray) {
        output += `${indentString.repeat(indent)}${value},\n`;
    } else {
        output += `${indentString.repeat(indent)}'${key}': ${value},\n`;
    }
}


function handleFunction(indent: number, prefix: string, key: string, englishFunc: Function, welshFunc: Function, isArray: boolean) {
    const getFuncBody = (func: Function): string => {
        if(!func) {
            return '';
        }

        const match = /^[^`]*`(.*)`$/s.exec(func.toString());

        if(!match) {
            console.error(`Couldn't parse function for '${prefix}' : ${func.toString()}`);
            return '';
        }

        return match[1];
    }

    const replaceFuncBody = (func: Function, newBody: string): string => {
        if(!func) {
            return '';
        }

        const match = /^([^`]*`)(.*)(`)$/s.exec(func.toString());

        if(!match) {
            console.error(`Couldn't parse function for '${prefix}' : ${func.toString()}`);
            return '';
        }

        const funcDefinition = match[1].replace(/\w+/g, '$&: string');

        return `${funcDefinition}${newBody}${match[3]}`;
    }

    if(recordMap[prefix] && recordMap[prefix].cy) {
        // We have a new Welsh translation
        writeValue(indent, key, replaceFuncBody(englishFunc, sanitise(recordMap[prefix].cy)), isArray);
        console.info(`${prefix}: Welsh function from CSV`);
    } else if(welshFunc) {
        writeValue(indent, key, replaceFuncBody(welshFunc, sanitise(getFuncBody(welshFunc))), isArray);
        console.info(`${prefix}: Welsh function from cy.ts`);
    } else {
        writeValue(indent, key, 'undefined', isArray);
        console.info(`${prefix}: Welsh function is undefined`);
    }
}

function handleString(indent: number, prefix: string, key: string, english: string, welsh: string, isArray: boolean) {
    if(recordMap[prefix] && recordMap[prefix].cy) {
        // We have a new Welsh translation
        writeValue(indent, key, JSON.stringify(sanitise(recordMap[prefix].cy)), isArray);
        console.info(`${prefix}: Welsh string from CSV`);
    } else if(welsh) {
        writeValue(indent, key, JSON.stringify(sanitise(welsh)), isArray);
        console.info(`${prefix}: Welsh string from cy.ts`);
    } else {
        writeValue(indent, key, 'undefined', isArray);
        console.info(`${prefix}: Welsh string is undefined`);
    }
}

function processSection(indent: number, prefix: string, key: string, englishSection: any, welshSection: any, parentIsArray: boolean) {
    const isArray = Array.isArray(englishSection);

    if(key) {
        output += indentString.repeat(indent);

        if(!parentIsArray) {
            output += `'${key}': `;
        }

        if(isArray) {
            output += '[\n';
        } else {
            output += '{\n';
        }
    }

    const indexes = isArray ? englishSection.map((value: any, i: number) => String(i)) : Object.keys(englishSection);

    for (const key of indexes) {
        if (Object.hasOwnProperty.call(englishSection, key)) {
            const element = englishSection[key];
            const welshElement = welshSection && !('' + welshSection[key]).includes('(Welsh)') ? welshSection[key] : undefined;

            const newPrefix = `${prefix}${prefix && '.'}${key}`;

            switch(typeof element) {
                case 'object':
                    processSection(indent + 1, newPrefix, key, element, welshElement, isArray);
                    break;

                case 'function':
                    handleFunction(indent + 1, newPrefix, key, element, welshElement, isArray);
                    break;

                case 'string':
                    handleString(indent + 1, newPrefix, key, element, welshElement, isArray);
                    break;

                default:
                    console.error(`Unknown type for key ${prefix} : ${typeof element}`);
            }

            csvKeyUsageTracker.delete(newPrefix);
        }
    }

    if(key) {
        if(isArray) {
            output += indentString.repeat(indent) + "],\n";
        } else {
            output += indentString.repeat(indent) + "},\n";
        }
    }

}

processSection(0, '', '', en.default, cy.default, false);

output += `};

export default Translation;
`;

fs.writeFileSync(outputFilename, output);

console.log('Unused CSV keys: ', csvKeyUsageTracker);
